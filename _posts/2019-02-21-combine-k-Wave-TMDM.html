---
title: Implementation of k-Wave for arbitrary shape transducer
---
<p>
<br>
<hr>
<hr>
This example shows how to implement the <a href="http://www.k-wave.org/">k-Wave</a> for simulations with curved transducer.
Currently, only phased array transducer can be used for simulating focused beams in the mSOUND. If other transducer settings
are required, people can first use k-Wave to propagate the wave field for a small distance and record the data at a plane. 
Then implement the recorded data at that plane to the TMDM as source pressure. In this example, a curved transduce is first modeled
with k-Wave.
<hr>
<hr>
</p>

<!---k-Wave simulation--->
<h6>Generate the source pressure with k-Wave</h6>
<hr>
<p>
 <br>
 <code>        
<br>dx = 1.8750e-04;         <font color="#03a852"> %  step size in the x direction [m]</font> 
<br>dy = 1.8750e-04;         <font color="#03a852"> %  step size in the y direction [m]</font> 
<br>dt = 6.2500e-08;         <font color="#03a852"> %  time step size [s]</font> 

<br>Nx = 240;    <font color="#03a852"> % total computatoinal domain size in x direction [grid points]</font> 
<br>Ny = 40;     <font color="#03a852"> % total computatoinal domain size in y direction [grid points]</font> 
<br>kgrid = kWaveGrid(Nx, dx, Ny, dy);              
</code>   
 <br>
</p>

<!---define a curved transducer with k-Wave--->
<h6>Define a curved transducer with k-Wave</h6>
<hr>
<p>
 In this example, a curved transducer is defined with k-Wave. 
<code>
<br>  
<br>TR_radius = 4*lambda;  <font color="#03a852"> % Transducer radius [m] </font> 
<br>TR_focus  = 10*lambda;  <font color="#03a852">  % Transducer focus length [m]</font>       
<br>focus  = round(TR_focus/dx);   
<br>cy = Ny/2-offcenter + focus;

<br>arc_angle1 = asin(TR_radius/TR_focus);
<br>circle1 = makeCircle(Nx, Ny, cx, cy, focus, arc_angle1, false);
<br>arc_angle2 = pi*2;
<br>circle2 = makeCircle(Nx, Ny, cx, cy, focus, arc_angle2, false);
<br>arc_angle3 = pi*2 - arc_angle1;
<br>circle3 = makeCircle(Nx, Ny, cx, cy, focus, arc_angle3, false);
<br>circle = circle2 - circle3 + circle1;
  
<br>source.p_mask = zeros(Nx, Ny);
<br>sensor.mask = zeros(Nx, Ny); 
<br>offcenter = floor(Ny_p/2);  <font color="#03a852">% propagation direction</font>      
<br>source.p_mask = circle;
<br>sensor.mask(:, Ny/2+offcenter) = 1; 
</code>
 </p>



<!---excitation signale--->
<h6>Excitation signal</h6>
<br>sample_freq = 1/dt; % [Hz]
<br>signal_freq = fc;  % [Hz]
<br>source_mag = p0;    % [Pa] 

<br>ts = [-num_cycles/fc:dt:num_cycles/fc];
<br>excit_p = sin(2*pi*fc*(ts)).*exp(-(ts).^2*fc^2/2);
<br>source.p = excit_p*p0;

<br>input_args  = {'DisplayMask', source.p_mask, 'DataCast', 'single',...
               'PlotScale',[-source_mag/2, source_mag/2]};
<br>sensor_data = kspaceFirstOrder2D(kgrid, medium, source, sensor, input_args{:});


